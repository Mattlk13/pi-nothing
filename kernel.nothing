;; -*- mode: scheme -*-

;; Copyright (C) 2012 Tony Garnock-Jones <tonygarnockjones@gmail.com>
;;
;; This file is part of pi-nothing.
;;
;; pi-nothing is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published
;; by the Free Software Foundation, either version 3 of the License,
;; or (at your option) any later version.
;;
;; pi-nothing is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with pi-nothing. If not, see <http://www.gnu.org/licenses/>.
;;
;;---------------------------------------------------------------------------
;; NOTE: The procedure (font0-bitmap), containing font data, is NOT
;; covered by the GPL, and is instead covered by the Bitstream Vera
;; Fonts Copyright license, which is available in the file
;; font0license.txt.
;;---------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interrupt table

;; TODO: Limitation on the linker means this routine has to be early
;; in the image, so that the offset to
;; sys:exception-handler-undefined-instruction etc isn't too large to
;; fit in an instruction. See the label-linker instance in
;; `indirect-immediate` in mach-arm7.rkt. A more flexible linker would
;; be able to put the needed value in the data quasisegment, like the
;; non-label branch does.
(define (configure-interrupt-table)
  (let ((mutable vec 0))
    (while (<u vec 8)
      (! (<< vec 2) #xe59ff018) ;; LDR PC, [PC, #24]
      (set! vec (+ vec 1))))
  (! #x20 interrupt:reset)
  (! #x24 sys:exception-handler-undefined-instruction)
  (! sys:interrupt-vector-undefined-instruction interrupt:undefined-instruction)
  (! #x28 sys:exception-handler-swi)
  (! sys:interrupt-vector-swi interrupt:swi)
  (! #x2c sys:exception-handler-prefetch-abort)
  (! sys:interrupt-vector-prefetch-abort interrupt:prefetch-abort)
  (! #x30 sys:exception-handler-data-abort)
  (! sys:interrupt-vector-data-abort interrupt:data-abort)
  (! #x34 interrupt:unused)
  (! #x38 sys:exception-handler-irq)
  (! sys:interrupt-vector-irq interrupt:irq)
  (! #x3c sys:exception-handler-fiq)
  (! sys:interrupt-vector-fiq interrupt:fiq))

(define (cpu-enable-interrupts)
  (sys:set-cpsr (binand (sys:get-cpsr) #xffffff3f))) ;; clear I and F bits

(define (cpu-disable-interrupts)
  (sys:set-cpsr (binor (sys:get-cpsr) #xc0))) ;; set I and F bits

(define (interrupt:reset)
  (error %error-unexpected-interrupt:reset)
  0)

(define (interrupt:undefined-instruction)
  (error %error-unexpected-interrupt:undefined-instruction)
  0) ;; either 0 or 4 depending on whether to skip the insn or retry it

(define (interrupt:swi)
  (error %error-unexpected-interrupt:swi)
  0) ;; will return immediately after the SWI

(define (interrupt:prefetch-abort)
  (error %error-unexpected-interrupt:prefetch-abort)
  0) ;; either 0 or 4 depending on whether to skip the insn or retry it

(define (interrupt:data-abort)
  (error %error-unexpected-interrupt:data-abort)
  0) ;; either 4 or 8 depending on whether to skip the insn or retry it

(define (interrupt:unused)
  (error %error-unexpected-interrupt:unused)
  0)

(define (interrupt:irq)
  (error %error-unexpected-interrupt:irq)
  ;; (? (+ vic0 vic-address)) ;; dummy read -- see vic-nonvectored-irq-status
  ;; (sys:set-spsr (binor (sys:get-spsr) #xc0)) ;; disable interrupts when we return from this handler.
  ;; ;; ^ we do this because we don't know which interrupt caused us
  ;; ;; here, so we can't clear the condition and will loop forever.
  ;; ;; We leave the clearing of the condition to user code.
  4) ;; not zero! otherwise we end up skipping an instruction

(define (interrupt:fiq)
  (error %error-unexpected-interrupt:fiq)
  4) ;; not zero! otherwise we end up skipping an instruction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const %error-division-by-zero				#x00000002)
(const %error-no-error					#x00000007)

(const %error-bad-mailbox-channel			#x00000010)
(const %error-bad-mailbox-pointer			#x00000011)
(const %error-unexpected-mailbox-message		#x00000012)

(const %error-framebuffer-mode-set-failed		#x00000020)

(const %error-unexpected-interrupt:reset			#x00000030)
(const %error-unexpected-interrupt:undefined-instruction	#x00000031)
(const %error-unexpected-interrupt:swi				#x00000032)
(const %error-unexpected-interrupt:prefetch-abort		#x00000033)
(const %error-unexpected-interrupt:data-abort			#x00000034)
(const %error-unexpected-interrupt:unused			#x00000035)
(const %error-unexpected-interrupt:irq				#x00000036)
(const %error-unexpected-interrupt:fiq				#x00000037)

(const %error-devicetree-bad-node-type			#x00000040)

(define (error code)
  (pulse-bits-forever code))

(define (error/argument code arg)
  (while (= 0 0)
    (pulse-bits code)
    (pulse-bits arg)
    (long-delay)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (division-by-zero a b)
  (error %error-division-by-zero))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (delay-countdown v)
  (let ((mutable n v))
    (while (>u n 0)
      (set! n (- n 1)))))

(define (short-delay)
  (delay-countdown #x200000))

(define (long-delay)
  (delay-countdown #x600000))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const %gpio-base #x20200000)
(const %gpio-function-select-0 #x0000) ;; GPIO pins 0-9
(const %gpio-function-select-1 #x0004) ;; GPIO pins 10-19
(const %gpio-pin-output-clear-0 #x0028) ;; GPIO pins 0-31
(const %gpio-pin-output-clear-1 #x002c) ;; GPIO pins 32-53
(const %gpio-pin-output-set-0 #x001c) ;; GPIO pins 0-31
(const %gpio-pin-output-set-1 #x0020) ;; GPIO pins 32-53

(const %gpio-pin-control-mask 7) ;; 3 bits
(const %gpio-pin-control-input 0) ;; pin is an input
(const %gpio-pin-control-output 1) ;; pin is an output
;; other values exist

(define (enable-led)
  (let ((reg (+ %gpio-base %gpio-function-select-1))) ;; pin 16.
    (let ((old (? reg)))
      (! reg (binor (binand old (<< (binnot %gpio-pin-control-mask) 18))
		    (<< %gpio-pin-control-output 18))))))

(define (set-led! state)
  (! (+ %gpio-base (if (<> state 0) %gpio-pin-output-clear-0 %gpio-pin-output-set-0))
     (<< 1 16)))

(define (pulse-bits bitfield)
  (if (<> bitfield 0)
      (let ((bit (binand bitfield 1)))
	(pulse-bits (>>u bitfield 1))
	(set-led! 1)
	(if (<> bit 0) (long-delay) (short-delay))
	(set-led! 0)
	(short-delay))
      (begin (set-led! 0)
	     (long-delay))))

(define (pulse-bits-forever bitfield)
  (while (= 0 0) (pulse-bits bitfield)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const $alloc-pointer-addr #x00200000) ;; Heap starts at 2MB - i.e. above the stack

(define (init-alloc!)
  (! $alloc-pointer-addr (+ $alloc-pointer-addr 16))) ;; can't use 4, is not 16-aligned

(define (*save-alloc-state*)
  (? $alloc-pointer-addr))

(define (*restore-alloc-state* saved-state)
  (! $alloc-pointer-addr saved-state))

(define (round-up-to-4 x) (binand #xfffffffc (+ x 3)))
(define (round-up-to-16 x) (binand #xfffffff0 (+ x 15)))

(define (alloc! size)
  ;; always returns a 16-byte aligned pointer
  (let ((rounded-size (round-up-to-16 size))
	(result (? $alloc-pointer-addr)))
    (! $alloc-pointer-addr (+ result rounded-size))
    result))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const %mailbox-base #x2000b880)

(const %mailbox-reg-read #x00)
(const %mailbox-reg-peek #x10)
(const %mailbox-reg-sender #x14)
(const %mailbox-reg-status #x18)
(const %mailbox-reg-config #x1c)
(const %mailbox-reg-write #x20)

(const %channel-power-management 0)
(const %channel-framebuffer 1)
(const %channel-virtual-uart 2)
(const %channel-vchiq 3)
(const %channel-leds 4)
(const %channel-buttons 5)
(const %channel-touchscreen 6)
;; 7 unused?
(const %channel-properties-arm->vc 8)
(const %channel-properties-vc->arm 9)

(define (mailbox-status)
  (? (+ %mailbox-base %mailbox-reg-status)))

(define (mailbox-send! mailbox-channel message-pointer)
  ;; TODO: what kinds of memory barriers are needed here and in
  ;; mailbox-recv? See http://elinux.org/RPi_Framebuffer.
  (when (>=u mailbox-channel 16) (error %error-bad-mailbox-channel))
  (when (<> (binand message-pointer 15) 0) (error %error-bad-mailbox-pointer))
  (while (<> (binand (mailbox-status) (<< 1 31)) 0))
  (! (+ %mailbox-base %mailbox-reg-write)
     (binor mailbox-channel message-pointer)))

(define (mailbox-recv mailbox-channel)
  (when (>=u mailbox-channel 16) (error %error-bad-mailbox-channel))
  (while (<> (binand (mailbox-status) (<< 1 30)) 0))
  (let ((pointer-and-channel (? (+ %mailbox-base %mailbox-reg-read))))
    (when (<> (binand pointer-and-channel 15) mailbox-channel)
      (error %error-unexpected-mailbox-message))
    (binand pointer-and-channel #xfffffff0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Mailbox property interface
;; https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface

;; Property buffer must be a multiple of 32 bits, i.e. a whole number of words.
;; Each tag needs to have enough internal sub-buffer space for its reply.

(struct property-buffer-header ((size word) ;; in bytes; includes this header
				(opcode word)
				;; Sequence of tags/values follows,
				;; terminated by %property-tag-end and
				;; padding to 4-byte alignment.
				))

(const %property-buffer-op-request #x00000000)
(const %property-buffer-op-response-ok #x80000000)
(const %property-buffer-op-response-error #x80000001) ;; "error parsing request buffer"

(struct property-buffer-tag ((id word)
			     (buffer-size word) ;; in bytes; EXCLUDES this header
			     (value-length word) ;; MSB 0=req, 1=resp; 31 bits value length in bytes
			     ;; Value buffer follows, buffer-size bytes.
			     ))

(const %property-tag-end #x00000000)
(const %property-tag-get-arm-memory #x00010005)
(const %property-tag-get-vc-memory #x00010006)

(struct property-memory-info ((base word)
			      (size word))) ;; in bytes

(define (get-*-memory con tag)
  (let ((*saved* (*save-alloc-state*)))
    (let ((buflen (round-up-to-4 (+ sizeof-property-buffer-header
				    sizeof-property-buffer-tag
				    8 ;; for response buffer
				    4)))) ;; for end tag
      (let ((buf (alloc! buflen)))
	(let ((tag-start (+ buf sizeof-property-buffer-header))
	      (value-start (+ buf sizeof-property-buffer-header sizeof-property-buffer-tag)))
	(! (+ buf property-buffer-header-size) buflen)
	(! (+ buf property-buffer-header-opcode) %property-buffer-op-request)
	(! (+ tag-start property-buffer-tag-id) tag)
	(! (+ tag-start property-buffer-tag-buffer-size) 8)
	(! (+ tag-start property-buffer-tag-value-length) 0)
	(! (+ value-start 8) %property-tag-end)
	(mailbox-send! %channel-properties-arm->vc buf)
	(let ((reply (mailbox-recv %channel-properties-arm->vc)))
	  ;; The reply seems to be the same as the buffer pointer we gave.
	  (when (<> reply buf)
	    (console-puts con (data #"(Weird, get-*-memory reply \0"))
	    (console-putx con reply)
	    (console-puts con (data #" isn't buf \0"))
	    (console-putx con buf)
	    (console-puts con (data #")\n\0"))))
	(let ((result (? (+ value-start property-memory-info-size))))
	  (*restore-alloc-state* *saved*)
	  result))))))

(define (get-arm-memory con) (get-*-memory con %property-tag-get-arm-memory))
(define (get-vc-memory con) (get-*-memory con %property-tag-get-vc-memory))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(struct framebuffer-description ((width word)
				 (height word)
				 (virtual-width word)
				 (virtual-height word)
				 (pitch word) ;; set by GPU
				 (depth word) ;; bits per pixel
				 (x-offset word)
				 (y-offset word)
				 (pointer word) ;; set by GPU
				 (size word))) ;; set by GPU

(define (framebuffer-pointer fbinfo) (? (+ fbinfo framebuffer-description-pointer)))
(define (framebuffer-stride fbinfo) (? (+ fbinfo framebuffer-description-pitch)))
(define (framebuffer-pixel-width fbinfo) (>>u (? (+ fbinfo framebuffer-description-depth)) 3))

(define (pointer->gpu-pointer v)
  (binor #x40000000 v))

(define (gpu-pointer->pointer v)
  (binand #x3fffffff v))

(define (initialize-framebuffer)
  (let ((fbinfo (alloc! sizeof-framebuffer-description))
	(W 1024)
	(H 768))
    (! (+ fbinfo framebuffer-description-width) W)
    (! (+ fbinfo framebuffer-description-height) H)
    (! (+ fbinfo framebuffer-description-virtual-width) W)
    (! (+ fbinfo framebuffer-description-virtual-height) H)
    (! (+ fbinfo framebuffer-description-pitch) 0)
    (! (+ fbinfo framebuffer-description-depth) 32)
    (! (+ fbinfo framebuffer-description-x-offset) 0)
    (! (+ fbinfo framebuffer-description-y-offset) 0)
    (! (+ fbinfo framebuffer-description-pointer) 0)
    (! (+ fbinfo framebuffer-description-size) 0)
    (mailbox-send! %channel-framebuffer (pointer->gpu-pointer fbinfo))
    (let ((result (mailbox-recv %channel-framebuffer)))
      (when (<> result 0) (error/argument %error-framebuffer-mode-set-failed result))
      (! (+ fbinfo framebuffer-description-pointer)
	 (gpu-pointer->pointer (? (+ fbinfo framebuffer-description-pointer))))
      fbinfo)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(struct console ((fbinfo word)
		 (x word)
		 (y word)
		 (width word)
		 (height word)))

(define (make-console fbinfo)
  (let ((c (alloc! sizeof-console)))
    (! (+ c console-fbinfo) fbinfo)
    (! (+ c console-x) 0)
    (! (+ c console-y) 0)
    (! (+ c console-width) (>>u (? (+ fbinfo framebuffer-description-width)) %char-width-shift))
    (! (+ c console-height) (>>u (? (+ fbinfo framebuffer-description-height)) %char-height-shift))
    c))

(define (console-putc con ch)
  (when (= ch 13)
    (! (+ con console-x) 0)
    (return 0))
  (when (= ch 10)
    (! (+ con console-x) 0)
    (! (+ con console-y) (+ (? (+ con console-y)) 1))
    (scroll-if-required con)
    (return 0))
  (blit-char (? (+ con console-fbinfo))
	     (<< (? (+ con console-x)) %char-width-shift)
	     (<< (? (+ con console-y)) %char-height-shift)
	     ch
	     #x00ffffff)
  (! (+ con console-x) (+ (? (+ con console-x)) 1))
  (when (= (? (+ con console-x)) (? (+ con console-width)))
    (console-putc con 10)))

(define (scroll-if-required con)
  (let ((height (? (+ con console-height))))
    (when (= (? (+ con console-y)) height)
      (let ((fbinfo (? (+ con console-fbinfo))))
	(let ((target (framebuffer-pointer fbinfo))
	      (offset (* (framebuffer-stride fbinfo) (<< 1 %char-height-shift)))
	      (limit (* (framebuffer-stride fbinfo) (<< 1 %char-height-shift) (- height 1))))
	  (let ((mutable n 0))
	    (while (<u n limit)
	      (! (+ target n) (? (+ target n offset)))
	      (set! n (+ n 4))))
	  (let ((mutable n 0))
	    (while (<u n offset)
	      (! (+ target limit n) 0)
	      (set! n (+ n 4))))))
      (! (+ con console-y) (- height 1)))))

(define (console-puts con p)
  (let ((ch (?byte p)))
    (when (<> ch 0)
      (console-putc con ch)
      (console-puts con (+ p 1)))))

(define (console-newline con)
  (console-putc con 10))

(define (console-putn* con i)
  (if (<> i 0)
      (begin (console-putn* con (/ i 10))
	     (console-putc con (+ (% i 10) 48)))
      0))

(define (console-putn i)
  (if (<> i 0)
      (console-putn* i)
      (console-putc 48)))

(define (console-putx con n)
  (let ((mutable shift 28))
    (while (>=s shift 0)
      (let ((digit (binand 15 (>>u n shift))))
	(console-putc con (+ digit (if (>=u digit 10)
				       55 ;; 65 - 10
				       48)))
	(set! shift (- shift 4))))))

(define (console-putxdigit con n)
  (let ((digit (binand 15 n)))
    (console-putc con (+ digit (if (>=u digit 10) 55 48)))))

(define (console-putx-block con bs len)
  (let ((mutable n 0))
    (while (<u n len)
      (let ((b (?byte (+ bs n))))
	(console-putxdigit con (>>u b 4))
	(console-putxdigit con b))
      (set! n (+ n 1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const ATAG_NONE	#x00000000)
(const ATAG_CORE	#x54410001)
(const ATAG_MEM		#x54410002)
(const ATAG_VIDEOTEXT	#x54410003)
(const ATAG_RAMDISK	#x54410004)
(const ATAG_INITRD2	#x54420005) ;; yes, really, not #x54410005. Presumably that was INITRD1?
(const ATAG_SERIAL	#x54410006)
(const ATAG_REVISION	#x54410007)
(const ATAG_VIDEOLFB	#x54410008)
(const ATAG_CMDLINE	#x54410009)

(define (dump-atag-word con base field-number description-str)
  (console-putc con 32)
  (console-putc con 32)
  (console-putx con (? (+ base (<< (+ field-number 2) 2))))
  (console-putc con 32)
  (console-puts con description-str)
  (console-newline con))

(define (dump-atag-core con base)
  (dump-atag-word con base 0 (data #"flags\0"))
  (dump-atag-word con base 1 (data #"pagesize\0"))
  (dump-atag-word con base 2 (data #"rootdev\0")))

(define (dump-atag-mem con base)
  (dump-atag-word con base 0 (data #"size\0"))
  (dump-atag-word con base 1 (data #"start\0")))

(define (dump-atag-cmdline con base)
  (console-putc con 32)
  (console-putc con 32)
  (console-puts con (+ base 8))
  (console-newline con))

(define (dump-atags con base)
  (let ((size (? base))
	(tag (? (+ base 4))))
    (console-puts con (data #"ATAG #x\0"))
    (console-putx con tag)
    (console-puts con (data #" size \0"))
    (console-putn con size)
    (console-newline con)
    (when (= tag ATAG_CORE) (dump-atag-core con base))
    (when (= tag ATAG_MEM) (dump-atag-mem con base))
    (when (= tag ATAG_CMDLINE) (dump-atag-cmdline con base))
    (when (<> tag ATAG_NONE)
      (dump-atags con (+ base (<< size 2))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(struct boot-param-header ((magic word)
			   (totalsize word)
			   (off_dt_struct word)
			   (off_dt_strings word)
			   (off_mem_rsvmap word)
			   (version word)
			   (last_comp_version word)
			   ;; Version 2 fields:
			   (boot_cpuid_phys word)
			   ;; Version 3 fields:
			   (size_dt_strings word)
			   ;; Version 17 fields:
			   (size_dt_struct word)))

(const OF_DT_HEADER	#xD00DFEED)
(const OF_DT_BEGIN_NODE #x00000001)
(const OF_DT_END_NODE	#x00000002)
(const OF_DT_PROP	#x00000003)
(const OF_DT_END	#x00000009)

(define (byte-swap v)
  (binor (>>u v 24)
	 (binand (>>u v 8) #xff00)
	 (binand (<< v 8) #xff0000)
	 (<< v 24)))

(define (?be addr)
  (byte-swap (? addr)))

(define (print-indent con amount)
  (let ((mutable n 0))
    (while (<u n amount)
      (console-putc con 32)
      (set! n (+ n 1)))))

(define (strlen p)
  (let ((mutable p p)
	(mutable count 0)
	(mutable ch (?byte p)))
    (while (<> ch 0)
      (set! count (+ count 1))
      (set! p (+ p 1))
      (set! ch (?byte p)))
    count))

(define (round-up-to-4-bytes n)
  (binand #xfffffffc (+ n 3)))

(define (dump-dt-properties con p strings-base indent)
  (let ((prop-type (?be p)))
    (if (<> prop-type OF_DT_PROP)
	p ;; return address of potential children (or end of node)
	(let ((prop-value-size (?be (+ p 4)))
	      (prop-name-offset (?be (+ p 8)))
	      (prop-value-base (+ p 12)))
	  (let ((next-p (+ prop-value-base (round-up-to-4-bytes prop-value-size)))
		(prop-name (+ strings-base prop-name-offset)))
	    (print-indent con indent)
	    (console-puts con prop-name)
	    (console-puts con (data #" size \0"))
	    (console-putn con prop-value-size)
	    (console-putc con 32)
	    (console-putx-block con prop-value-base prop-value-size)
	    (console-newline con)
	    (dump-dt-properties con next-p strings-base indent))))))

(define (dump-dt-children con p strings-base indent)
  (let ((node-type (?be p)))
    (if (logor (= node-type OF_DT_END_NODE)
	       (= node-type OF_DT_END))
	(+ p 4) ;; return address of next (potential) node
	(if (<> node-type OF_DT_BEGIN_NODE)
	    (begin (console-puts con (data #"Unexpected devicetree node type \0"))
		   (console-putx con node-type)
		   (console-newline con)
		   (error %error-devicetree-bad-node-type))
	    (let ((prop-base
		   (let ((node-name (+ p 4)))
		     (print-indent con indent)
		     (console-putc con 34)
		     (console-puts con node-name)
		     (console-putc con 34)
		     (console-newline con)
		     (+ node-name (round-up-to-4-bytes (+ (strlen node-name) 1))))))
	      (let ((children-base (dump-dt-properties con prop-base strings-base (+ indent 2))))
		(let ((next-p (dump-dt-children con children-base strings-base (+ indent 2))))
		  (dump-dt-children con next-p strings-base indent))))))))

(define (dump-block-be con p word-count)
  (console-putx con p)
  (console-putc con 58)
  (let ((mutable n 0))
    (while (<u n word-count)
      (console-putc con 32)
      (console-putx con (?be (+ p (<< n 2))))
      (let ((column (binand n 3)))
	(set! n (+ n 1))
	(when (= column 3)
	  (console-newline con)
	  (console-putx con (+ p (<< n 2)))
	  (console-putc con 58))))))

(define (dump-devicetree con base)
  (when (= (?be (+ base boot-param-header-magic)) OF_DT_HEADER)
    (let ((totalsize (?be (+ base boot-param-header-totalsize)))
	  (struct-base (+ base (?be (+ base boot-param-header-off_dt_struct))))
	  (strings-base (+ base (?be (+ base boot-param-header-off_dt_strings))))
	  (memory-map-base (+ base (?be (+ base boot-param-header-off_mem_rsvmap))))
	  (version (?be (+ base boot-param-header-version))))
      (console-puts con (data #"Devicetree version \0"))
      (console-putn con version)
      (console-newline con)
      (when (>=u version 16) ;; earlier versions have full paths
			     ;; instead of node leaf names - we don't
	;; support the older format
	;; (dump-block-be con struct-base 64 #;(>>u totalsize 2))
	(console-putx con base) (console-newline con)
	(console-putx con struct-base) (console-newline con)
	(console-putx con strings-base) (console-newline con)
	(console-putx con memory-map-base) (console-newline con)
	(dump-dt-children con struct-base strings-base 2)
	(console-puts con (data #"Done printing devicetree.\0"))
	))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (print-banner con)
  (console-puts con
		(data #"Welcome to MINOS for Raspberry Pi\n"
		      #"Copyright (C) 2012 Tony Garnock-Jones <tonygarnockjones@gmail.com>\n\0")))

(define (print-memory-info con)
  (console-puts con (data #"ARM memory \0"))
  (console-putn con (get-arm-memory con))
  (console-puts con (data #" bytes; VC memory \0"))
  (console-putn con (get-vc-memory con))
  (console-puts con (data #" bytes\n\0")))

(define (main always-zero machine-type atags-base)
  (enable-led)
  (configure-interrupt-table)
  (init-alloc!)
  (let ((fbinfo (initialize-framebuffer)))
    (let ((con (make-console fbinfo)))
      (print-banner con)
      (print-memory-info con)

      (console-puts con (data #"Machine type \0"))
      (console-putn con machine-type)
      (console-newline con)

      (when (= (? (+ atags-base 4)) ATAG_CORE)
	(dump-atags con atags-base))

      (dump-devicetree con atags-base)

      (cpu-enable-interrupts)
      (sys:wait-for-interrupt)
      (error %error-no-error))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(const %char-width-shift 3)
(const %char-height-shift 4)

(define (blit-char fbinfo x y ch color)
  (let ((stride (framebuffer-stride fbinfo))
	(pixwidth (framebuffer-pixel-width fbinfo)))
    (let ((mutable p (+ (font0-bitmap) (<< ch %char-height-shift)))
	  (mutable target-leftmost (+ (framebuffer-pointer fbinfo)
				(* y stride)
				(* x pixwidth))))
      (let ((limit (+ p (<< 1 %char-height-shift))))
	(while (<u p limit)
	  (let ((mutable target target-leftmost)
		(mutable pixel 0)
		(row (?byte p)))
	    (while (<u pixel (<< 1 %char-width-shift))
	      (! target (if (<> (binand row (<< 1 pixel)) 0) color 0))
	      (set! pixel (+ pixel 1))
	      (set! target (+ target pixwidth)))
	  (set! p (+ p 1))
	  (set! target-leftmost (+ target-leftmost stride))))))))

(define (font0-bitmap)
  ;; Monospace Default font, from
  ;; http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/downloads.html:
  ;; "These fonts are the simplest ones available. They use a 1 to
  ;; represent a white pixel, a 0 to represent a black pixel, and
  ;; having representations for the first 128 ASCII characters. The
  ;; use 16 bytes per character, arranged such that each byte is one
  ;; complete row, going left to right with higher bits, going top to
  ;; bottom with later bytes."
  ;;
  ;; NOTE that this font data is covered by the license in
  ;; font0license.txt, not by the GPL.
  ;;
  (data #"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\b\b\b\b\b\0\b\b\0\0\0\0\0\0\0\24\24\24\24\0\0\0\0\0\0\0\0\0\0\0HHh\376$$\177\24\22\22\0\0\0\0\0\0\0\20|\222\22\34p\220\222|\20\20\0\0\0\0\0\6\t\tF8f\220\220`\0\0\0\0\0\0\08\4\4\f\222\262\242F\274\0\0\0\0\0\0\0\b\b\b\b\0\0\0\0\0\0\0\0\0\0000\20\20\b\b\b\b\b\b\20\20 \0\0\0\0\f\b\b\20\20\20\20\20\20\b\b\f\0\0\0\0\0\0\20\222|8\326\20\0\0\0\0\0\0\0\0\0\0\0\b\b\b\177\b\b\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\30\30\b\4\0\0\0\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\30\30\0\0\0\0\0\0\0@  \20\20\30\b\b\4\4\2\0\0\0\0\08D\202\202\222\202\202D8\0\0\0\0\0\0\0\34\20\20\20\20\20\20\20|\0\0\0\0\0\0\0|\302\200\200@0\30\4\376\0\0\0\0\0\0\0|\202\200\3008\300\200\302|\0\0\0\0\0\0\0`PXHDB\376@@\0\0\0\0\0\0\0~\2\2>\300\200\200\302<\0\0\0\0\0\0\0x\204\2z\306\202\202\304x\0\0\0\0\0\0\0\376@@  \20\30\b\4\0\0\0\0\0\0\0|\202\202\202|\202\202\206|\0\0\0\0\0\0\0<F\202\202\306\274\200B<\0\0\0\0\0\0\0\0\0\30\30\0\0\0\30\30\0\0\0\0\0\0\0\0\0\30\30\0\0\0\30\30\b\4\0\0\0\0\0\0\0\200p\16\16p\200\0\0\0\0\0\0\0\0\0\0\0\376\0\0\376\0\0\0\0\0\0\0\0\0\0\0\2\34\340\340\34\2\0\0\0\0\0\0\0\0\34\" \20\b\b\0\b\b\0\0\0\0\0\0\0x\314\204\342\222\222\222\342\4\fx\0\0\0\0\0\20(((DD|\306\202\0\0\0\0\0\0\0~\202\202\202~\202\202\202~\0\0\0\0\0\0\0x\204\2\2\2\2\2\204x\0\0\0\0\0\0\0>B\202\202\202\202\202B>\0\0\0\0\0\0\0\376\2\2\2\376\2\2\2\376\0\0\0\0\0\0\0\376\2\2\2\376\2\2\2\2\0\0\0\0\0\0\0x\204\2\2\302\202\202\204x\0\0\0\0\0\0\0\202\202\202\202\376\202\202\202\202\0\0\0\0\0\0\0>\b\b\b\b\b\b\b>\0\0\0\0\0\0\08      \"\34\0\0\0\0\0\0\0B\"\22\n\16\22\"\"B\0\0\0\0\0\0\0\2\2\2\2\2\2\2\2\376\0\0\0\0\0\0\0\306\306\252\252\252\222\202\202\202\0\0\0\0\0\0\0\206\206\212\212\222\242\242\302\302\0\0\0\0\0\0\08D\202\202\202\202\202D8\0\0\0\0\0\0\0~\302\202\202\302~\2\2\2\0\0\0\0\0\0\08D\202\202\202\202\202Dx`@\0\0\0\0\0~\302\202\202~B\202\202\2\0\0\0\0\0\0\0|\206\2\6|\300\200\302}\0\0\0\0\0\0\0\177\b\b\b\b\b\b\b\b\0\0\0\0\0\0\0\202\202\202\202\202\202\202\202|\0\0\0\0\0\0\0\202\306DDD(((\20\0\0\0\0\0\0\0\201\201\201ZZZfff\0\0\0\0\0\0\0\306D(8\20(lD\202\0\0\0\0\0\0\0A\"\24\24\b\b\b\b\b\0\0\0\0\0\0\0\376\300` \20\b\f\6\376\0\0\0\0\08\b\b\b\b\b\b\b\b\b\b8\0\0\0\0\0\0\2\4\4\b\b\30\20\20  @\0\0\0\34\20\20\20\20\20\20\20\20\20\20\34\0\0\0\0\0\0\b\24\"c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\177\0\0\0\b\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\08D@|Bb\\\0\0\0\0\0\2\2\2\2>fBBBf>\0\0\0\0\0\0\0\0\08D\2\2\2D8\0\0\0\0\0@@@@|fBBBf|\0\0\0\0\0\0\0\0\0<fB~\2F<\0\0\0\0\0000\b\b\b>\b\b\b\b\b\b\0\0\0\0\0\0\0\0\0|fBBBf\\@D8\0\0\2\2\2\2:FBBBBB\0\0\0\0\0\b\0\0\0\16\b\b\b\b\b>\0\0\0\0\0\20\0\0\0\34\20\20\20\20\20\20\20\20\16\0\0\2\2\2\2\"\22\n\16\22\"B\0\0\0\0\0\16\b\b\b\b\b\b\b\b\bp\0\0\0\0\0\0\0\0\0\376\222\222\222\222\222\222\0\0\0\0\0\0\0\0\0:FBBBBB\0\0\0\0\0\0\0\0\0<fBBBf<\0\0\0\0\0\0\0\0\0>fBBBf>\2\2\2\0\0\0\0\0\0|fBBBf\\@@@\0\0\0\0\0\0<L\4\4\4\4\4\0\0\0\0\0\0\0\0\0<B\2<@B<\0\0\0\0\0\0\0\b\b~\b\b\b\b\bp\0\0\0\0\0\0\0\0\0BBBBBb\\\0\0\0\0\0\0\0\0\0Bf$$<\30\30\0\0\0\0\0\0\0\0\0\201\201ZZZ$$\0\0\0\0\0\0\0\0\0f$\30\30\30$f\0\0\0\0\0\0\0\0\0BD$$(\30\20\20\b\f\0\0\0\0\0\0~@ \30\4\2~\0\0\0\0\08\b\b\b\b\6\b\b\b\b\b0\0\0\0\0\b\b\b\b\b\b\b\b\b\b\b\b\b\0\0\0\16\b\b\b\b0\b\b\b\b\b\6\0\0\0\0\0\0\0\0\0\0\234b\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"))